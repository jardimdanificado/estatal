<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3d map editor</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    :root {
      --bg: #0f1115;
      --panel: #151a22;
      --panel2: #10151d;
      --text: #e6e9ef;
      --muted: #9aa4b2;
      --line: rgba(255,255,255,0.08);
      --accent: #7dd3fc;
      --bad: #fb7185;
      --good: #34d399;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      height: 100vh;
      background: var(--bg);
      color: var(--text);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      overflow: hidden;
    }
    #app {
      display: grid;
      grid-template-columns: 360px 1fr;
      height: 100vh;
    }
    #sidebar {
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      border-right: 1px solid var(--line);
      padding: 12px;
      overflow: auto;
    }
    #viewport {
      position: relative;
      height: 100vh;
      overflow: hidden;
    }
    #hud {
      position: absolute;
      left: 12px;
      top: 12px;
      display: flex;
      gap: 8px;
      align-items: center;
      padding: 8px 10px;
      background: rgba(0,0,0,0.35);
      border: 1px solid var(--line);
      border-radius: 12px;
      backdrop-filter: blur(6px);
      user-select: none;
      pointer-events: none;
    }
    #hud b { color: var(--accent); }

    h1 {
      font-size: 16px;
      margin: 0 0 10px 0;
      letter-spacing: 0.3px;
    }
    h2 {
      font-size: 13px;
      margin: 14px 0 8px;
      color: var(--muted);
      font-weight: 700;
      letter-spacing: 0.2px;
      text-transform: uppercase;
    }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    .row3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; }

    label {
      display: block;
      font-size: 12px;
      color: var(--muted);
      margin: 8px 0 6px;
    }

    select, input[type="text"], input[type="number"] {
      width: 100%;
      padding: 9px 10px;
      border-radius: 10px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,0.25);
      color: var(--text);
      outline: none;
    }
    input[type="checkbox"] { transform: translateY(1px); }

    .btnbar { display: flex; flex-wrap: wrap; gap: 8px; }
    button {
      padding: 9px 10px;
      border-radius: 10px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,0.04);
      color: var(--text);
      cursor: pointer;
    }
    button:hover { border-color: rgba(255,255,255,0.18); }
    button.primary { background: rgba(125, 211, 252, 0.12); border-color: rgba(125, 211, 252, 0.35); }
    button.good { background: rgba(52, 211, 153, 0.12); border-color: rgba(52, 211, 153, 0.35); }
    button.bad { background: rgba(251, 113, 133, 0.12); border-color: rgba(251, 113, 133, 0.35); }

    .hint {
      margin-top: 10px;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.35;
      border: 1px dashed var(--line);
      border-radius: 12px;
      padding: 10px;
    }

    .palette {
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
      margin-top: 10px;
    }

    .card {
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px;
      background: rgba(0,0,0,0.18);
    }

    .entry {
      display: grid;
      grid-template-columns: 36px 1fr;
      gap: 10px;
      align-items: center;
      padding: 8px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.06);
      background: rgba(255,255,255,0.03);
      cursor: pointer;
      user-select: none;
    }
    .entry:hover { border-color: rgba(255,255,255,0.18); }
    .entry.active { outline: 2px solid rgba(125, 211, 252, 0.5); border-color: rgba(125, 211, 252, 0.35); }

    .thumb {
      width: 36px;
      height: 36px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(0,0,0,0.2);
      display: grid;
      place-items: center;
      overflow: hidden;
    }
    .thumb img { width: 100%; height: 100%; object-fit: cover; image-rendering: pixelated; }
    .meta { display: grid; gap: 2px; }
    .meta .name { font-size: 13px; }
    .meta .sub { font-size: 11px; color: var(--muted); }

    .status {
      margin-top: 10px;
      font-size: 12px;
      color: var(--muted);
      padding: 8px;
      border-radius: 12px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,0.2);
      white-space: pre-wrap;
    }

    a { color: var(--accent); }
  </style>
</head>
<body>
  <div id="app">
    <aside id="sidebar">
      <h1>Editor 3D (voxels)</h1>

      <div class="card">
        <h2>Mapa</h2>
        <div class="btnbar">
          <button class="primary" id="btn-load-default">Carregar default.json</button>
          <button id="btn-import">Importar…</button>
          <button class="good" id="btn-export">Exportar JSON</button>
          <button class="bad" id="btn-clear">Limpar</button>
        </div>
        <div class="status" id="status">Pronto.</div>
      </div>

      <div class="card" style="margin-top: 10px;">
        <h2>Ferramenta</h2>
        <label>Modo</label>
        <div class="row">
          <select id="tool-mode">
            <option value="block">Bloco</option>
            <option value="floor">Chão (isFloor)</option>
            <option value="npc">Entidade (NPC)</option>
            <option value="item">Item (drop)</option>
            <option value="erase">Apagar</option>
          </select>
          <div>
            <label style="margin-top:0;">Camada Y</label>
            <input id="layer-y" type="number" value="0" step="1" />
          </div>
        </div>

        <label>Busca no catálogo</label>
        <input id="search" type="text" placeholder="filtrar por nome…" />

        <div class="hint">
          <b>Controles:</b><br/>
          - Clique esquerdo: aplicar<br/>
          - Shift + clique: apagar (atalho)<br/>
          - Arrastar com mouse: orbitar a câmera<br/>
          - Rodinha: zoom<br/>
          <br/>
          <b>Dica:</b> blocos sólidos usam (x,z) inteiros. NPCs/itens usam centro (x+0.5, z+0.5).
        </div>
      </div>

      <div class="card" style="margin-top: 10px;">
        <h2>Paleta</h2>
        <div class="palette" id="palette"></div>
      </div>

      <div class="card" style="margin-top: 10px;">
        <h2>Links</h2>
        <div style="font-size:12px; color: var(--muted); line-height:1.35;">
          <div>- <a href="./index.html">Voltar pro jogo (index.html)</a></div>
          <div>- <a href="./editor2d.html">Editor 2D (camadas)</a></div>
        </div>
      </div>
    </aside>

    <main id="viewport">
      <div id="hud"></div>
    </main>
  </div>

  <script type="module">
        // ------------------------------------------------------------
    // IMPORTS COM FALLBACK (pra você poder mover /data/config -> /src)
    // ------------------------------------------------------------
    async function importWithFallback(candidates) {
      let lastErr = null;
      for (const p of candidates) {
        try { return await import(p); } catch (e) { lastErr = e; }
      }
      throw lastErr || new Error('Falha ao importar módulos.');
    }

    const [{ default: CONFIG }, { default: BLOCK_TYPES }, { default: NPC_TYPES }, { default: ITEMS }, { default: texturesToLoad }] = await Promise.all([
      importWithFallback(['./data/config/config.js', './data/config/config.js']),
      importWithFallback(['./data/config/blocks.js', './data/config/blocks.js']),
      importWithFallback(['./data/config/npcs.js', './data/config/npcs.js']),
      importWithFallback(['./data/config/items.js', './data/config/items.js']),
      importWithFallback(['./data/config/textures.js', './data/config/textures.js']),
    ]);


    // ----------------------------
    // Util
    // ----------------------------
    const $ = (id) => document.getElementById(id);
    const statusEl = $('status');
    const hudEl = $('hud');

    function setStatus(msg) { statusEl.textContent = msg; }

    const textureUrlByKey = texturesToLoad.reduce((m, e) => (m[e.key] = e.url, m), {});
    function getBlockThumbKey(bt) {
      const t = bt && bt.textures ? bt.textures : null;
      return t ? (t.all || t.top || t.side || t.bottom || null) : null;
    }

    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

    // ----------------------------
    // Data catalogs
    // ----------------------------
    const blockList = Object.values(BLOCK_TYPES)
      .slice()
      .sort((a, b) => (a.name || '').localeCompare(b.name || ''))
      .map((bt) => ({
        kind: 'block',
        id: bt.id,
        label: bt.name,
        bt,
        thumbKey: getBlockThumbKey(bt),
      }));

    const npcList = Object.values(NPC_TYPES)
      .slice()
      .sort((a, b) => (a.name || '').localeCompare(b.name || ''))
      .map((npc) => ({
        kind: 'npc',
        id: npc.id,
        label: npc.name,
        npc,
        thumbKey: npc.texture || 'npc',
      }));

    const itemList = Object.values(ITEMS)
      .slice()
      .sort((a, b) => (a.name || '').localeCompare(b.name || ''))
      .map((it) => ({
        kind: 'item',
        id: it.id,
        label: it.name,
        it,
        thumbKey: it.textureKey || null,
      }));

    // ----------------------------
    // Editor state
    // ----------------------------
    const state = {
      toolMode: 'block',
      layerY: 0,
      selected: null, // palette entry
      map: {
        version: 1,
        player: { x: 7.5, y: 2, z: 7.5, yaw: 0, pitch: 0 },
        blocks: [],
        items: [],
        entities: [],
      }
    };

    // ----------------------------
    // THREE: scene, camera, orbit
    // ----------------------------
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0f14);

    const camera = new THREE.PerspectiveCamera(70, 1, 0.05, 2000);

    const renderer = new THREE.WebGLRenderer({ antialias: false });
    renderer.setPixelRatio(1);
    renderer.setSize(1, 1);
    $('viewport').appendChild(renderer.domElement);

    const amb = new THREE.AmbientLight(0xffffff, 0.75);
    scene.add(amb);
    const dir = new THREE.DirectionalLight(0xffffff, 0.55);
    dir.position.set(12, 18, 10);
    scene.add(dir);

    const grid = new THREE.GridHelper(200, 200, 0x334155, 0x1f2937);
    grid.position.y = -0.5;
    scene.add(grid);

    // Orbit controller (minimal)
    const orbit = {
      target: new THREE.Vector3(7.5, 0, 7.5),
      radius: 20,
      theta: Math.PI * 0.9,
      phi: Math.PI * 0.35,
      dragging: false,
      lastX: 0,
      lastY: 0,
      button: 0,
    };

    function updateCamera() {
      orbit.phi = clamp(orbit.phi, 0.08, Math.PI - 0.08);
      orbit.radius = clamp(orbit.radius, 4, 250);
      const sinPhi = Math.sin(orbit.phi);
      const x = orbit.target.x + orbit.radius * sinPhi * Math.cos(orbit.theta);
      const y = orbit.target.y + orbit.radius * Math.cos(orbit.phi);
      const z = orbit.target.z + orbit.radius * sinPhi * Math.sin(orbit.theta);
      camera.position.set(x, y, z);
      camera.lookAt(orbit.target);
    }

    updateCamera();

    // Resize
    function onResize() {
      const rect = $('viewport').getBoundingClientRect();
      camera.aspect = rect.width / rect.height;
      camera.updateProjectionMatrix();
      renderer.setSize(rect.width, rect.height);
    }
    window.addEventListener('resize', onResize);
    onResize();

    // Orbit input
    renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
    renderer.domElement.addEventListener('pointerdown', (e) => {
      orbit.dragging = true;
      orbit.lastX = e.clientX;
      orbit.lastY = e.clientY;
      orbit.button = e.button;
      renderer.domElement.setPointerCapture(e.pointerId);
    });
    renderer.domElement.addEventListener('pointerup', () => { orbit.dragging = false; });
    renderer.domElement.addEventListener('pointermove', (e) => {
      if (!orbit.dragging) return;
      const dx = e.clientX - orbit.lastX;
      const dy = e.clientY - orbit.lastY;
      orbit.lastX = e.clientX;
      orbit.lastY = e.clientY;

      if (orbit.button === 2) {
        // pan
        const panSpeed = orbit.radius * 0.0009;
        const right = new THREE.Vector3();
        camera.getWorldDirection(right);
        right.cross(camera.up).normalize();
        const up = new THREE.Vector3().copy(camera.up).normalize();
        orbit.target.addScaledVector(right, -dx * panSpeed);
        orbit.target.addScaledVector(up, dy * panSpeed);
      } else {
        // rotate
        orbit.theta -= dx * 0.006;
        orbit.phi -= dy * 0.006;
      }
      updateCamera();
    });

    renderer.domElement.addEventListener('wheel', (e) => {
      e.preventDefault();
      orbit.radius *= (e.deltaY > 0) ? 1.08 : 0.92;
      updateCamera();
    }, { passive: false });

    // ----------------------------
    // Lazy texture cache for THREE
    // ----------------------------
    const texLoader = new THREE.TextureLoader();
    const textureCache = new Map(); // key -> Promise<Texture|null>

    function loadTexture(key) {
      if (!key) return Promise.resolve(null);
      if (!textureUrlByKey[key]) return Promise.resolve(null);
      if (textureCache.has(key)) return textureCache.get(key);
      const p = new Promise((resolve) => {
        texLoader.load(
          textureUrlByKey[key],
          (tex) => {
            tex.magFilter = THREE.NearestFilter;
            tex.minFilter = THREE.NearestMipMapNearestFilter;
            resolve(tex);
          },
          undefined,
          () => resolve(null)
        );
      });
      textureCache.set(key, p);
      return p;
    }

    function makeBlockMaterials(bt) {
      const opacity = (typeof bt.opacity === 'number') ? bt.opacity : 1;
      const transparent = opacity < 1;

      const mats = [];
      for (let i = 0; i < 6; i++) {
        mats.push(new THREE.MeshLambertMaterial({ color: 0x64748b, transparent, opacity }));
      }

      const t = bt.textures || {};
      const all = t.all || null;
      if (all) {
        loadTexture(all).then((tex) => {
          if (!tex) return;
          for (const m of mats) {
            m.map = tex;
            m.needsUpdate = true;
          }
        });
        return mats;
      }

      const top = t.top || null;
      const side = t.side || null;
      const bottom = t.bottom || null;

      // Order in world.js: [side, side, top, bottom, side, side]
      const setMap = (mat, key) => {
        loadTexture(key).then((tex) => {
          if (!tex) return;
          mat.map = tex;
          mat.needsUpdate = true;
        });
      };

      if (side) { setMap(mats[0], side); setMap(mats[1], side); setMap(mats[4], side); setMap(mats[5], side); }
      if (top) setMap(mats[2], top);
      if (bottom) setMap(mats[3], bottom);

      return mats;
    }

    function makeCrossMesh(bt) {
      const size = CONFIG.BLOCK_SIZE || 1;
      const t = bt.textures || {};
      const key = t.all || t.top || null;
      const opacity = (typeof bt.opacity === 'number') ? bt.opacity : 1;

      const geom = new THREE.PlaneGeometry(size, size);
      const matA = new THREE.MeshLambertMaterial({
        color: 0xffffff,
        transparent: true,
        opacity,
        side: THREE.DoubleSide,
        alphaTest: 0.1,
      });
      const matB = matA.clone();

      loadTexture(key).then((tex) => {
        if (!tex) return;
        matA.map = tex; matA.needsUpdate = true;
        matB.map = tex; matB.needsUpdate = true;
      });

      const a = new THREE.Mesh(geom, matA);
      const b = new THREE.Mesh(geom, matB);
      a.rotation.y = Math.PI / 4;
      b.rotation.y = -Math.PI / 4;
      const g = new THREE.Group();
      g.add(a); g.add(b);
      return g;
    }

    function makeNpcBillboard(npc) {
      const h = npc.height || 1.6;
      const w = npc.width || 0.8;
      const geom = new THREE.PlaneGeometry(w, h);
      const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, alphaTest: 0.1, side: THREE.DoubleSide });
      loadTexture(npc.texture || 'npc').then((tex) => {
        if (!tex) return;
        mat.map = tex;
        mat.needsUpdate = true;
      });
      const mesh = new THREE.Mesh(geom, mat);
      return mesh;
    }

    function makeItemBillboard(itemDef) {
      const base = 0.55;
      const geom = new THREE.PlaneGeometry(base, base);
      const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, alphaTest: 0.1, side: THREE.DoubleSide });
      loadTexture(itemDef.textureKey || null).then((tex) => {
        if (!tex) return;
        mat.map = tex;
        mat.needsUpdate = true;
      });
      return new THREE.Mesh(geom, mat);
    }

    // ----------------------------
    // Map runtime meshes
    // ----------------------------
    const runtime = {
      blocks: [], // {x,y,z,typeId,isFloor, mesh}
      entities: [], // {.., mesh}
      items: [], // {.., mesh}
    };

    function keyBlock(x,y,z) { return `${x}|${y}|${z}`; }
    const blockIndex = new Map();

    function addBlockToScene(entry) {
      const bt = Object.values(BLOCK_TYPES).find(b => b.id === entry.typeId);
      if (!bt) return;

      const isCross = bt.render === 'cross';
      const mesh = isCross
        ? makeCrossMesh(bt)
        : new THREE.Mesh(new THREE.BoxGeometry(CONFIG.BLOCK_SIZE || 1, CONFIG.BLOCK_SIZE || 1, CONFIG.BLOCK_SIZE || 1), makeBlockMaterials(bt));

      mesh.position.set(entry.x, entry.y, entry.z);
      mesh.userData.kind = 'block';
      mesh.userData.ref = entry;
      scene.add(mesh);

      entry.mesh = mesh;
      runtime.blocks.push(entry);
      blockIndex.set(keyBlock(entry.x, entry.y, entry.z), entry);
    }

    function removeBlockFromScene(entry) {
      if (!entry) return;
      if (entry.mesh) scene.remove(entry.mesh);
      blockIndex.delete(keyBlock(entry.x, entry.y, entry.z));
      const i = runtime.blocks.indexOf(entry);
      if (i >= 0) runtime.blocks.splice(i, 1);
    }

    function addNpcToScene(entry) {
      const npc = Object.values(NPC_TYPES).find(n => n.id === entry.npcTypeId);
      if (!npc) return;
      const mesh = makeNpcBillboard(npc);
      mesh.position.set(entry.x, entry.y, entry.z);
      mesh.userData.kind = 'entity';
      mesh.userData.ref = entry;
      scene.add(mesh);
      entry.mesh = mesh;
      runtime.entities.push(entry);
    }

    function addItemToScene(entry) {
      if (entry.kind !== 'item') return;
      const it = Object.values(ITEMS).find(i => i.id === entry.itemId);
      if (!it) return;
      const mesh = makeItemBillboard(it);
      mesh.position.set(entry.x, entry.y, entry.z);
      mesh.userData.kind = 'item';
      mesh.userData.ref = entry;
      scene.add(mesh);
      entry.mesh = mesh;
      runtime.items.push(entry);
    }

    function clearSceneMap() {
      for (const b of runtime.blocks) if (b.mesh) scene.remove(b.mesh);
      for (const e of runtime.entities) if (e.mesh) scene.remove(e.mesh);
      for (const it of runtime.items) if (it.mesh) scene.remove(it.mesh);
      runtime.blocks = [];
      runtime.entities = [];
      runtime.items = [];
      blockIndex.clear();
    }

    function applyPayload(payload) {
      if (!payload || !Array.isArray(payload.blocks)) {
        setStatus('Mapa inválido.');
        return;
      }

      clearSceneMap();

      state.map = {
        version: payload.version || 1,
        player: payload.player || { x: 7.5, y: 2, z: 7.5, yaw: 0, pitch: 0 },
        blocks: (payload.blocks || []).map(b => ({...b})),
        items: (payload.items || []).map(i => ({...i})),
        entities: (payload.entities || []).map(e => ({...e})),
      };

      for (const b of state.map.blocks) addBlockToScene(b);
      for (const it of (state.map.items || [])) addItemToScene(it);
      for (const e of (state.map.entities || [])) {
        if (e.type === 'npc') addNpcToScene(e);
      }

      // Center orbit roughly
      const center = payload.player ? new THREE.Vector3(payload.player.x, 0, payload.player.z) : new THREE.Vector3(0,0,0);
      orbit.target.copy(center);
      updateCamera();

      setStatus(`Carregado. Blocos: ${state.map.blocks.length}, NPCs: ${state.map.entities.length}, Itens: ${state.map.items.length}`);
    }

    function buildPayloadFromRuntime() {
      return {
        version: 1,
        player: state.map.player || { x: 7.5, y: 2, z: 7.5, yaw: 0, pitch: 0 },
        blocks: runtime.blocks.map(b => ({ x: b.x, y: b.y, z: b.z, typeId: b.typeId, isFloor: !!b.isFloor })),
        items: runtime.items.map(i => ({ kind: i.kind, blockTypeId: i.blockTypeId || null, itemId: i.itemId || null, amount: i.amount || 1, x: i.x, y: i.y, z: i.z })),
        entities: runtime.entities.map(e => ({
          type: e.type,
          npcTypeId: e.npcTypeId || null,
          name: e.name || null,
          faction: e.faction || null,
          x: e.x, y: e.y, z: e.z,
          yaw: e.yaw || 0,
          pitch: e.pitch || 0,
          hp: (typeof e.hp === 'number') ? e.hp : 100,
          maxHP: (typeof e.maxHP === 'number') ? e.maxHP : 100,
          isHostile: !!e.isHostile,
        }))
      };
    }

    // ----------------------------
    // Palette UI
    // ----------------------------
    const paletteEl = $('palette');
    const searchEl = $('search');
    const toolEl = $('tool-mode');
    const layerEl = $('layer-y');

    function getActiveList() {
      const mode = state.toolMode;
      if (mode === 'npc') return npcList;
      if (mode === 'item') return itemList;
      // block / floor share same
      return blockList;
    }

    function renderPalette() {
      paletteEl.innerHTML = '';
      const q = (searchEl.value || '').trim().toLowerCase();
      const list = getActiveList().filter(e => !q || (e.label || '').toLowerCase().includes(q));

      if (!state.selected || state.selected.kind !== (state.toolMode === 'npc' ? 'npc' : state.toolMode === 'item' ? 'item' : 'block')) {
        state.selected = list[0] || null;
      }

      for (const entry of list.slice(0, 2200)) {
        const div = document.createElement('div');
        div.className = 'entry' + (state.selected === entry ? ' active' : '');
        const thumb = document.createElement('div');
        thumb.className = 'thumb';
        const k = entry.thumbKey;
        if (k && textureUrlByKey[k]) {
          const img = document.createElement('img');
          img.src = textureUrlByKey[k];
          img.alt = '';
          thumb.appendChild(img);
        } else {
          thumb.textContent = entry.kind === 'npc' ? 'NPC' : entry.kind === 'item' ? 'IT' : 'BL';
        }

        const meta = document.createElement('div');
        meta.className = 'meta';
        const name = document.createElement('div');
        name.className = 'name';
        name.textContent = entry.label || '—';
        const sub = document.createElement('div');
        sub.className = 'sub';
        sub.textContent = `${entry.kind.toUpperCase()} • id=${entry.id}`;
        meta.appendChild(name);
        meta.appendChild(sub);

        div.appendChild(thumb);
        div.appendChild(meta);
        div.addEventListener('click', () => {
          state.selected = entry;
          renderPalette();
        });

        paletteEl.appendChild(div);
      }

      setHud();
    }

    function setHud(extra = '') {
      const sel = state.selected;
      const selText = sel ? `${sel.label} (id=${sel.id})` : '—';
      const y = state.layerY;
      hudEl.innerHTML = `Modo: <b>${state.toolMode}</b> • Camada Y: <b>${y}</b> • Seleção: <b>${selText}</b>${extra ? ' • ' + extra : ''}`;
    }

    toolEl.addEventListener('change', () => {
      state.toolMode = toolEl.value;
      renderPalette();
    });

    layerEl.addEventListener('change', () => {
      state.layerY = Math.trunc(Number(layerEl.value || 0));
      layerEl.value = String(state.layerY);
      setHud();
    });

    searchEl.addEventListener('input', renderPalette);

    // ----------------------------
    // Placement: raycast to plane and snap
    // ----------------------------
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    const ghostMat = new THREE.MeshBasicMaterial({ color: 0x7dd3fc, transparent: true, opacity: 0.25 });
    const ghost = new THREE.Mesh(new THREE.BoxGeometry(1.02, 1.02, 1.02), ghostMat);
    ghost.visible = false;
    scene.add(ghost);

    function getPlacementY() {
      if (state.toolMode === 'floor') return -0.5;
      if (state.toolMode === 'block') return state.layerY + 0.5;
      // npc/item use ground plane at y=0
      return 0;
    }

    function screenToRay(e) {
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -(((e.clientY - rect.top) / rect.height) * 2 - 1);
      raycaster.setFromCamera(mouse, camera);
    }

    function raycastToPlaneY(y) {
      const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -y);
      const pt = new THREE.Vector3();
      const ok = raycaster.ray.intersectPlane(plane, pt);
      return ok ? pt : null;
    }

    function snapXZ(pt) {
      const x = Math.round(pt.x);
      const z = Math.round(pt.z);
      return { x, z };
    }

    function tryEraseAt(pos) {
      // Prefer erasing blocks, then entities/items
      const b = blockIndex.get(keyBlock(pos.x, pos.y, pos.z));
      if (b) {
        removeBlockFromScene(b);
        return true;
      }
      // Erase NPC/item in cell (centered)
      const cx = pos.x + 0.5;
      const cz = pos.z + 0.5;
      for (let i = runtime.entities.length - 1; i >= 0; i--) {
        const e = runtime.entities[i];
        if (Math.abs(e.x - cx) < 0.51 && Math.abs(e.z - cz) < 0.51) {
          if (e.mesh) scene.remove(e.mesh);
          runtime.entities.splice(i, 1);
          return true;
        }
      }
      for (let i = runtime.items.length - 1; i >= 0; i--) {
        const it = runtime.items[i];
        if (Math.abs(it.x - cx) < 0.51 && Math.abs(it.z - cz) < 0.51) {
          if (it.mesh) scene.remove(it.mesh);
          runtime.items.splice(i, 1);
          return true;
        }
      }
      return false;
    }

    function placeAt(snapped, isShift) {
      const mode = state.toolMode;
      const y = getPlacementY();

      if (isShift || mode === 'erase') {
        const did = tryEraseAt({ x: snapped.x, y: (mode === 'npc' || mode === 'item') ? 0 : y, z: snapped.z });
        if (did) setStatus(`Apagado em (${snapped.x}, ${y}, ${snapped.z}).`);
        return;
      }

      if (!state.selected) return;

      if (mode === 'block' || mode === 'floor') {
        const bt = state.selected.bt;
        if (!bt) return;
        const entry = { x: snapped.x, y, z: snapped.z, typeId: bt.id, isFloor: (mode === 'floor') };
        const k = keyBlock(entry.x, entry.y, entry.z);
        if (blockIndex.has(k)) {
          // Replace
          removeBlockFromScene(blockIndex.get(k));
        }
        addBlockToScene(entry);
        setStatus(`Bloco: ${bt.name} em (${entry.x}, ${entry.y}, ${entry.z})`);
        return;
      }

      if (mode === 'npc') {
        const npc = state.selected.npc;
        if (!npc) return;
        const entry = {
          type: 'npc',
          npcTypeId: npc.id,
          name: npc.name,
          faction: npc.faction || null,
          x: snapped.x + 0.5,
          y: 0,
          z: snapped.z + 0.5,
          yaw: 0,
          pitch: 0,
          hp: npc.maxHP || 100,
          maxHP: npc.maxHP || 100,
          isHostile: !!npc.isHostile,
        };
        addNpcToScene(entry);
        setStatus(`NPC: ${npc.name} em (${snapped.x + 0.5}, 0, ${snapped.z + 0.5})`);
        return;
      }

      if (mode === 'item') {
        const it = state.selected.it;
        if (!it) return;
        const entry = {
          kind: 'item',
          itemId: it.id,
          amount: 1,
          x: snapped.x + 0.5,
          y: 0.2,
          z: snapped.z + 0.5,
        };
        addItemToScene(entry);
        setStatus(`Item: ${it.name} em (${entry.x}, ${entry.y}, ${entry.z})`);
        return;
      }
    }

    renderer.domElement.addEventListener('pointermove', (e) => {
      screenToRay(e);
      const pt = raycastToPlaneY(getPlacementY());
      if (!pt) { ghost.visible = false; return; }
      const { x, z } = snapXZ(pt);
      ghost.visible = (state.toolMode === 'block' || state.toolMode === 'floor');
      if (ghost.visible) {
        ghost.position.set(x, getPlacementY(), z);
      }
      setHud(`Cursor: (${x}, ${getPlacementY()}, ${z})`);
    });

    renderer.domElement.addEventListener('click', (e) => {
      // If user was dragging orbit, ignore a click that comes with big move.
      // (Simple heuristic: if pointerdown->up moved, we still might get click. Keep it simple.)
      screenToRay(e);
      const pt = raycastToPlaneY(getPlacementY());
      if (!pt) return;
      const snapped = snapXZ(pt);
      placeAt(snapped, e.shiftKey);
    });

    // ----------------------------
    // Import / Export
    // ----------------------------
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = 'application/json';
    fileInput.style.display = 'none';
    document.body.appendChild(fileInput);

    $('btn-import').addEventListener('click', () => {
      fileInput.value = '';
      fileInput.click();
    });

    fileInput.addEventListener('change', () => {
      const file = fileInput.files && fileInput.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const payload = JSON.parse(String(reader.result || ''));
          applyPayload(payload);
        } catch {
          setStatus('Falha ao importar: JSON inválido.');
        }
      };
      reader.readAsText(file);
    });

    $('btn-export').addEventListener('click', () => {
      const payload = buildPayloadFromRuntime();
      const data = JSON.stringify(payload, null, 2);
      const blob = new Blob([data], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'map.json';
      a.click();
      URL.revokeObjectURL(url);
      setStatus('Exportado: map.json');
    });

    $('btn-load-default').addEventListener('click', async () => {
      try {
        const resp = await fetch('./data/maps/default.json');
        if (!resp.ok) throw new Error(String(resp.status));
        const payload = await resp.json();
        applyPayload(payload);
      } catch (err) {
        setStatus('Falha ao carregar ./data/maps/default.json');
      }
    });

    $('btn-clear').addEventListener('click', () => {
      clearSceneMap();
      setStatus('Mapa limpo.');
    });

    // ----------------------------
    // Render loop
    // ----------------------------
    function tick() {
      // make billboards face camera
      for (const e of runtime.entities) {
        if (e.mesh) e.mesh.lookAt(camera.position);
      }
      for (const it of runtime.items) {
        if (it.mesh) it.mesh.lookAt(camera.position);
      }
      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }

    // Boot
    state.toolMode = toolEl.value;
    state.layerY = Math.trunc(Number(layerEl.value || 0));
    renderPalette();
    setHud();
    tick();

  </script>
</body>
</html>
