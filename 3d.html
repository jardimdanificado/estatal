<!DOCTYPE html>
<html lang="pt-br">
<head>
<meta charset="UTF-8">
<title>doom-like 3d using three.js</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<style>
    body {
        margin: 0;
        background: black;
        overflow: hidden;
    }
    canvas {
        display: block;
    }
</style>
</head>
<body>
<script>
const MOVE_SPEED = 0.08;
const ROT_SPEED = 0.03;
const PLAYER_RADIUS = 0.3;
const WALL_HEIGHT = 2;
const TILE_SIZE = 1;

const mapData = [
    [1,1,1,1,1,1,1,1,1,1],
    [1,-1,-1,-2,-2,-2,-2,-1,-1,1],
    [1,-1,2,-2,-3,-3,3,-2,-1,1],
    [1,-2,-2,-3,-3,-3,-3,-2,-2,1],
    [1,-2,-3,-3,-1,-1,-3,-3,-2,1],
    [1,-2,-2,-3,3,-1,2,-2,-2,1],
    [1,-1,-1,-2,-2,-2,-2,-1,-1,1],
    [1,1,1,1,1,1,1,1,1,1],
];

const MAP_W = mapData[0].length;
const MAP_H = mapData.length;

let scene, camera, renderer;
let player = {
    x: 3.5,
    z: 3.5,
    angle: 0
};
let keys = {};
let walls = [];
let npcs = [];
let texturesLoaded = false;
let wallTextures = {};
let floorTextures = {};
let npcTexture;

function loadTextures() {
    const loader = new THREE.TextureLoader();
    
    // Texturas de parede
    loader.load('./dcss/dungeon/wall/metal_wall_brown.png', (tex) => {
        tex.wrapS = THREE.RepeatWrapping;
        tex.wrapT = THREE.RepeatWrapping;
        tex.magFilter = THREE.NearestFilter;
        tex.minFilter = THREE.NearestFilter;
        wallTextures[1] = tex;
        checkTexturesLoaded();
    });
    loader.load('./dcss/dungeon/wall/stone2_gray_3_old.png', (tex) => {
        tex.wrapS = THREE.RepeatWrapping;
        tex.wrapT = THREE.RepeatWrapping;
        tex.magFilter = THREE.NearestFilter;
        tex.minFilter = THREE.NearestFilter;
        wallTextures[2] = tex;
        checkTexturesLoaded();
    });
    loader.load('./dcss/dungeon/wall/slime_stone_0.png', (tex) => {
        tex.wrapS = THREE.RepeatWrapping;
        tex.wrapT = THREE.RepeatWrapping;
        tex.magFilter = THREE.NearestFilter;
        tex.minFilter = THREE.NearestFilter;
        wallTextures[3] = tex;
        checkTexturesLoaded();
    });
    
    // Texturas de chão
    loader.load('./dcss/dungeon/wall/slime_stone_0.png', (tex) => {
        tex.wrapS = THREE.RepeatWrapping;
        tex.wrapT = THREE.RepeatWrapping;
        tex.magFilter = THREE.NearestFilter;
        tex.minFilter = THREE.NearestFilter;
        floorTextures[1] = tex;
        checkTexturesLoaded();
    });
    loader.load('./dcss/dungeon/wall/slime_stone_0.png', (tex) => {
        tex.wrapS = THREE.RepeatWrapping;
        tex.wrapT = THREE.RepeatWrapping;
        tex.magFilter = THREE.NearestFilter;
        tex.minFilter = THREE.NearestFilter;
        floorTextures[2] = tex;
        checkTexturesLoaded();
    });
    loader.load('./dcss/dungeon/wall/slime_stone_0.png', (tex) => {
        tex.wrapS = THREE.RepeatWrapping;
        tex.wrapT = THREE.RepeatWrapping;
        tex.magFilter = THREE.NearestFilter;
        tex.minFilter = THREE.NearestFilter;
        floorTextures[3] = tex;
        checkTexturesLoaded();
    });
    
    loader.load('./dcss/player/base/human_male.png', (tex) => {
        tex.magFilter = THREE.NearestFilter;
        tex.minFilter = THREE.NearestFilter;
        npcTexture = tex;
        checkTexturesLoaded();
    });
}

function checkTexturesLoaded() {
    if (Object.keys(wallTextures).length === 3 && 
        Object.keys(floorTextures).length === 3 && 
        npcTexture) {
        texturesLoaded = true;
        createWorld();
        createNPCs();
    }
}

function init() {
    // Scene
    scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x1a1a2e, 1, 12);
    scene.background = new THREE.Color(0x1a1a2e);
    
    // Camera (primeira pessoa)
    camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
    );
    camera.position.set(player.x, 1, player.z);
    
    // Renderer
    renderer = new THREE.WebGLRenderer({ antialias: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
    document.body.appendChild(renderer.domElement);
    
    // Luz ambiente
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
    scene.add(ambientLight);
    
    // Luz direcional
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.3);
    dirLight.position.set(5, 10, 5);
    scene.add(dirLight);
    
    loadTextures();
    
    window.addEventListener('resize', onWindowResize);
    document.addEventListener('keydown', (e) => keys[e.keyCode] = true);
    document.addEventListener('keyup', (e) => keys[e.keyCode] = false);
    
    document.addEventListener('click', () => {
        document.body.requestPointerLock();
    });
    
    document.addEventListener('mousemove', onMouseMove);
    
    animate();
}

function createWorld() {
    // Criar paredes e chão
    for (let y = 0; y < MAP_H; y++) {
        for (let x = 0; x < MAP_W; x++) {
            const cell = mapData[y][x];
            
            // Parede
            if (cell > 0) {
                const geometry = new THREE.BoxGeometry(TILE_SIZE, WALL_HEIGHT, TILE_SIZE);
                const material = new THREE.MeshLambertMaterial({
                    map: wallTextures[cell]
                });
                const wall = new THREE.Mesh(geometry, material);
                wall.position.set(x, WALL_HEIGHT / 2, y);
                wall.userData = { isWall: true, x: x, z: y };
                scene.add(wall);
                walls.push(wall);
            }
            // Chão
            else if (cell < 0) {
                const texIndex = Math.abs(cell);
                const geometry = new THREE.PlaneGeometry(TILE_SIZE, TILE_SIZE);
                const material = new THREE.MeshLambertMaterial({
                    map: floorTextures[texIndex],
                    side: THREE.DoubleSide
                });
                const floor = new THREE.Mesh(geometry, material);
                floor.rotation.x = -Math.PI / 2;
                floor.position.set(x, 0, y);
                scene.add(floor);
            }
        }
    }
    
    // Teto
    const ceilingGeo = new THREE.PlaneGeometry(MAP_W, MAP_H);
    const ceilingMat = new THREE.MeshLambertMaterial({
        color: 0x2a2a3e,
        side: THREE.DoubleSide
    });
    const ceiling = new THREE.Mesh(ceilingGeo, ceilingMat);
    ceiling.rotation.x = Math.PI / 2;
    ceiling.position.set(MAP_W / 2 - 0.5, WALL_HEIGHT, MAP_H / 2 - 0.5);
    scene.add(ceiling);
}

/* ============================================================
 * CRIAR NPCs (BILLBOARDS)
 * ============================================================ */
function createNPCs() {
    const npcPositions = [
        { x: 2.5, z: 2.5 },
        { x: 6.5, z: 5.5 },
        { x: 5.0, z: 3.0 },
        { x: 4.5, z: 5.0 }
    ];
    
    npcPositions.forEach(pos => {
        const geometry = new THREE.PlaneGeometry(0.8, 1.2);
        const material = new THREE.MeshBasicMaterial({
            map: npcTexture,
            transparent: true,
            alphaTest: 0.5,
            side: THREE.DoubleSide
        });
        const sprite = new THREE.Mesh(geometry, material);
        sprite.position.set(pos.x, 0.6, pos.z);
        
        scene.add(sprite);
        npcs.push(sprite);
    });
}

/* ============================================================
 * COLISÃO
 * ============================================================ */
function checkCollision(newX, newZ) {
    for (let wall of walls) {
        const wx = wall.userData.x;
        const wz = wall.userData.z;
        
        const halfTile = TILE_SIZE / 2;
        
        const closestX = Math.max(wx - halfTile, Math.min(newX, wx + halfTile));
        const closestZ = Math.max(wz - halfTile, Math.min(newZ, wz + halfTile));
        
        const distX = newX - closestX;
        const distZ = newZ - closestZ;
        const distSquared = distX * distX + distZ * distZ;
        
        if (distSquared < (PLAYER_RADIUS * PLAYER_RADIUS)) {
            return true;
        }
    }
    
    return false;
}

/* ============================================================
 * UPDATE
 * ============================================================ */
function updatePlayer() {
    // Rotação com setas
    if (keys[37]) player.angle += ROT_SPEED; // Left
    if (keys[39]) player.angle -= ROT_SPEED; // Right
    
    // Calcular direção de movimento baseado no ângulo da câmera
    // X aponta para direita, Z aponta para frente (em Three.js)
    const forward = {
        x: -Math.sin(player.angle),
        z: -Math.cos(player.angle)
    };
    
    const right = {
        x: Math.cos(player.angle),
        z: -Math.sin(player.angle)
    };
    
    // Movimento
    let moveX = 0;
    let moveZ = 0;
    
    if (keys[87]) { // W - Frente
        moveX += forward.x * MOVE_SPEED;
        moveZ += forward.z * MOVE_SPEED;
    }
    if (keys[83]) { // S - Trás
        moveX -= forward.x * MOVE_SPEED;
        moveZ -= forward.z * MOVE_SPEED;
    }
    if (keys[65]) { // A - Esquerda
        moveX -= right.x * MOVE_SPEED;
        moveZ -= right.z * MOVE_SPEED;
    }
    if (keys[68]) { // D - Direita
        moveX += right.x * MOVE_SPEED;
        moveZ += right.z * MOVE_SPEED;
    }
    
    // Aplicar movimento com colisão separada por eixo
    const newX = player.x + moveX;
    const newZ = player.z + moveZ;
    
    if (!checkCollision(newX, player.z)) {
        player.x = newX;
    }
    
    if (!checkCollision(player.x, newZ)) {
        player.z = newZ;
    }
    
    camera.position.x = player.x;
    camera.position.z = player.z;
    
    camera.rotation.y = player.angle;
}

function onMouseMove(event) {
    if (document.pointerLockElement === document.body) {
        player.angle -= event.movementX * 0.002;
    }
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}


function animate() {
    requestAnimationFrame(animate);
    
    if (texturesLoaded) {
        updatePlayer();
        
        npcs.forEach(npc => {
            npc.lookAt(camera.position);
        });
    }
    
    renderer.render(scene, camera);
}

init();
</script>
</body>
</html>